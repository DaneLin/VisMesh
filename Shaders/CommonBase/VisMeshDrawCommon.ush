// 每个立方体需要的顶点数: 6个面 * 2个三角形 * 3个顶点 = 36
#define VERTS_PER_BOX_INSTANCE 36

// 球体细分度配置 (默认值)
#ifndef SPHERE_SEGS
	#define SPHERE_SEGS 8   // 经度切片
#endif

#ifndef SPHERE_RINGS
	#define SPHERE_RINGS 6  // 纬度切片
#endif

// 计算球体总顶点数: Rings * Segs * 2(Triangles) * 3(Verts)
#define VERTS_PER_SPHERE_INSTANCE (SPHERE_RINGS * SPHERE_SEGS * 6)

/**
 * 伪随机数生成器 (基于 ID 和 Seed)
 * 返回: float3 (0.0 ~ 1.0)
 */
float3 Random3(uint ID, float InSeed)
{
	float3 p = float3(ID, ID, ID);
	float3 noise = float3(
		dot(p, float3(127.1, 311.7, 74.7)),
		dot(p, float3(269.5, 183.3, 246.1)),
		dot(p, float3(113.5, 271.9, 124.6))
	);
	return frac(sin(noise + InSeed) * 43758.5453);
}

void WriteVertex(RWBuffer<float> OutInstanceVertices, uint StartOffset, uint VIdx, float3 Pos)
{
	OutInstanceVertices[StartOffset + (VIdx) * 3 + 0] = Pos.x;
	OutInstanceVertices[StartOffset + (VIdx) * 3 + 1] = Pos.y;
	OutInstanceVertices[StartOffset + (VIdx) * 3 + 2] = Pos.z;
}

/**
 * 生成面朝相机的带宽度线段 (Billboard Line) - 世界空间固定宽度版本
 */
void AppendLineSegment(RWBuffer<float> OutBuffer, uint StartOffset, inout int v, float3 StartPos, float3 EndPos, float Width, float3 CameraPos)
{
	float3 LineDir = EndPos - StartPos;
	float Len = length(LineDir);
    
	if (Len < 0.0001f) return;
    
	LineDir /= Len;

	float3 ToCamera = normalize(CameraPos - (StartPos + EndPos) * 0.5f);
	float3 Right = cross(ToCamera, LineDir);
    
	if (length(Right) < 0.0001f)
	{
		Right = float3(0, 0, 1); 
	}
	else
	{
		Right = normalize(Right);
	}

	float3 OffsetVec = Right * (Width * 0.5f);

	float3 p0 = StartPos - OffsetVec;
	float3 p1 = StartPos + OffsetVec;
	float3 p2 = EndPos + OffsetVec;
	float3 p3 = EndPos - OffsetVec;

	WriteVertex(OutBuffer, StartOffset, v++, p0);
	WriteVertex(OutBuffer, StartOffset, v++, p1);
	WriteVertex(OutBuffer, StartOffset, v++, p2);

	WriteVertex(OutBuffer, StartOffset, v++, p0);
	WriteVertex(OutBuffer, StartOffset, v++, p2);
	WriteVertex(OutBuffer, StartOffset, v++, p3);
}

/**
 * 生成面朝相机的带宽度线段 (Billboard Line) - 屏幕空间等宽版本
 * @param OutBuffer          输出顶点缓冲区
 * @param StartOffset        当前Instance在缓冲区中的起始偏移
 * @param v                  [inout] 当前顶点计数器 (会自动累加)
 * @param P0                 线段起点 (Local/World Space)
 * @param P1                 线段终点 (Local/World Space)
 * @param TargetWidthPixels  目标像素宽度
 * @param CameraPosWS        相机位置 (相同空间)
 * @param ViewportSize       屏幕分辨率 (宽, 高)
 * @param TanHalfFOV         tan(FOV/2)
 */
void AppendLineSegment(
	RWBuffer<float> OutBuffer, 
	uint StartOffset, 
	inout int v, 
	float3 P0, 
	float3 P1, 
	float TargetWidthPixels,
	float3 CameraPosWS,
	float2 ViewportSize,
	float TanHalfFOV
)
{
	// 1. 计算线段方向和长度
	float3 LineDir = P1 - P0;
	float LineLength = length(LineDir);
	
	if (LineLength < 0.0001f) 
		return;
	
	LineDir = normalize(LineDir);

	// 2. 计算线段中点到相机的方向
	float3 MidPoint = (P0 + P1) * 0.5f;
	float3 ToCamera = CameraPosWS - MidPoint;
	float DistToCamera = length(ToCamera);
	ToCamera = normalize(ToCamera);

	// 3. 计算 Billboard 的 "右向量" (垂直于线段和视线)
	float3 Right = normalize(cross(ToCamera, LineDir));
	
	// 如果线段几乎平行于视线，使用备用向量
	if (length(cross(LineDir, ToCamera)) < 0.0001f)
	{
		// 使用世界上方向作为备用
		Right = normalize(cross(LineDir, float3(0, 0, 1)));
		if (length(Right) < 0.0001f)
		{
			Right = float3(1, 0, 0);
		}
	}

	// 4. 计算两个端点的距离（用于计算各自的宽度）
	float Dist0 = length(P0 - CameraPosWS);
	float Dist1 = length(P1 - CameraPosWS);

	// 5. 计算每个端点处的世界空间宽度
	// 公式: WorldUnitPerPixel = (2 * Distance * tan(FOV/2)) / ViewportHeight
	float WorldUnitPerPixel0 = (2.0f * Dist0 * TanHalfFOV) / ViewportSize.y;
	float WorldUnitPerPixel1 = (2.0f * Dist1 * TanHalfFOV) / ViewportSize.y;

	// 实际宽度 = 目标像素宽度 * 单位像素对应的世界单位
	float Width0 = TargetWidthPixels * WorldUnitPerPixel0;
	float Width1 = TargetWidthPixels * WorldUnitPerPixel1;

	// 6. 计算四个角点
	float3 V0 = P0 - Right * (Width0 * 0.5f);  // 起点左侧
	float3 V1 = P0 + Right * (Width0 * 0.5f);  // 起点右侧
	float3 V2 = P1 + Right * (Width1 * 0.5f);  // 终点右侧
	float3 V3 = P1 - Right * (Width1 * 0.5f);  // 终点左侧

	// 7. 生成两个三角形 (确保正确的 CCW 绕序)
	// Triangle 1: V0 -> V1 -> V2
	WriteVertex(OutBuffer, StartOffset, v++, V0);
	WriteVertex(OutBuffer, StartOffset, v++, V1);
	WriteVertex(OutBuffer, StartOffset, v++, V2);

	// Triangle 2: V0 -> V2 -> V3
	WriteVertex(OutBuffer, StartOffset, v++, V0);
	WriteVertex(OutBuffer, StartOffset, v++, V2);
	WriteVertex(OutBuffer, StartOffset, v++, V3);
}

/**
 * 球面坐标转笛卡尔坐标
 */
float3 GetSpherePoint(float Theta, float Phi, float R)
{
	float x = R * sin(Theta) * cos(Phi);
	float y = R * sin(Theta) * sin(Phi);
	float z = R * cos(Theta);
	return float3(x, y, z);
}

/**
 * 生成球体几何体
 * @param OutBuffer    输出顶点缓冲区
 * @param StartOffset  当前Instance在缓冲区中的起始偏移
 * @param v            [inout] 当前顶点计数器
 * @param Center       球心位置
 * @param Radius       半径
 */
void AppendSphere(RWBuffer<float> OutBuffer, uint StartOffset, inout int v, float3 Center, float Radius)
{
	// 遍历纬度 (Rings)
	for (int r = 0; r < SPHERE_RINGS; ++r)
	{
		// 遍历经度 (Segments)
		for (int s = 0; s < SPHERE_SEGS; ++s)
		{
			// 计算当前格子的四个角的比例 (0~1)
			float r0 = (float)r / (float)SPHERE_RINGS;
			float r1 = (float)(r + 1) / (float)SPHERE_RINGS;
			float s0 = (float)s / (float)SPHERE_SEGS;
			float s1 = (float)(s + 1) / (float)SPHERE_SEGS;

			// 转换为弧度
			float theta0 = r0 * PI;
			float theta1 = r1 * PI;
			float phi0 = s0 * 2.0f * PI;
			float phi1 = s1 * 2.0f * PI;

			// 计算四个角的局部坐标 + 偏移
			float3 p0 = Center + GetSpherePoint(theta0, phi0, Radius); // Top-Left
			float3 p1 = Center + GetSpherePoint(theta0, phi1, Radius); // Top-Right
			float3 p2 = Center + GetSpherePoint(theta1, phi0, Radius); // Bottom-Left
			float3 p3 = Center + GetSpherePoint(theta1, phi1, Radius); // Bottom-Right

			// 写入两个三角形 (逆时针 CCW)
			// Triangle 1: Top-Left -> Bottom-Left -> Top-Right
			WriteVertex(OutBuffer, StartOffset, v++, p0); // [cite: 1]
			WriteVertex(OutBuffer, StartOffset, v++, p2);
			WriteVertex(OutBuffer, StartOffset, v++, p1);

			// Triangle 2: Top-Right -> Bottom-Left -> Bottom-Right
			WriteVertex(OutBuffer, StartOffset, v++, p1);
			WriteVertex(OutBuffer, StartOffset, v++, p2);
			WriteVertex(OutBuffer, StartOffset, v++, p3);
		}
	}
}