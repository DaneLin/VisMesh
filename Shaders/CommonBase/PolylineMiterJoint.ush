/*=============================================================================
    PolylineMiterJoint.ush
    多段线斜接连接算法实现
=============================================================================*/

#include "/Engine/Private/Common.ush"

// Miter 限制系数，防止尖锐角导致的长度发散
#define MITER_LIMIT 3.0f
#define EPSILON 0.0001f

void WriteVertex(RWBuffer<float> OutBuffer, uint Offset, uint VIdx, float3 Pos)
{
    OutBuffer[Offset + VIdx * 3 + 0] = Pos.x;
    OutBuffer[Offset + VIdx * 3 + 1] = Pos.y;
    OutBuffer[Offset + VIdx * 3 + 2] = Pos.z;
}

/**
 * 计算斜接向量
 * @param Prev      前一个顶点位置
 * @param Current   当前顶点位置  
 * @param Next      下一个顶点位置
 * @param Width     线宽（世界空间或经过距离补偿后的宽度）
 * @param OutLeft   [out] 左侧偏移向量
 * @param OutRight  [out] 右侧偏移向量
 * @return          是否成功计算（false表示退化情况）
 */
bool ComputeMiterVectors(
    float3 Prev,
    float3 Current, 
    float3 Next,
    float Width,
    out float3 OutLeft,
    out float3 OutRight
)
{
    // 1. 计算两条线段的方向向量
    float3 DirPrev = normalize(Current - Prev);
    float3 DirNext = normalize(Next - Current);
    
    // 2. 计算法向量（假设在XY平面，法向量为Z轴）
    // 对于3D情况，需要根据实际情况选择合适的参考向量
    float3 UpVector = float3(0, 0, 1);
    
    // 3. 计算两条线段的侧向向量（垂直于线段方向）
    float3 ePrev = normalize(cross(UpVector, DirPrev));
    float3 eNext = normalize(cross(UpVector, DirNext));
    
    // 4. 计算斜接向量：两个侧向向量的平均
    float3 MiterVec = normalize(ePrev + eNext);
    float MiterLen = length(ePrev + eNext);
    
    // 5. 处理退化情况：两条线段近乎平行
    if (MiterLen < EPSILON)
    {
        // 直接使用单侧扩展向量
        OutLeft = ePrev * (Width * 0.5f);
        OutRight = -ePrev * (Width * 0.5f);
        return true;
    }
    
    // 6. 计算斜接长度比例
    // MiterLength = Width / (2 * sin(theta/2))
    // 其中 sin(theta/2) = |ePrev × eNext| / 2
    float sinHalfAngle = length(cross(ePrev, eNext)) * 0.5f;
    
    if (sinHalfAngle < EPSILON)
    {
        // 180度角，退化处理
        OutLeft = ePrev * (Width * 0.5f);
        OutRight = -ePrev * (Width * 0.5f);
        return true;
    }
    
    float MiterScale = 1.0f / (2.0f * sinHalfAngle);
    
    // 7. 应用限制，防止尖锐角导致的长度发散
    MiterScale = min(MiterScale, MITER_LIMIT);
    
    // 8. 确定斜接方向（左或右）
    // 通过叉积判断转向
    float3 Cross = cross(DirPrev, DirNext);
    float TurnSign = dot(Cross, UpVector);
    
    if (TurnSign > 0) // 左转
    {
        OutLeft = MiterVec * (Width * MiterScale);
        OutRight = -MiterVec * (Width * MiterScale);
    }
    else // 右转
    {
        OutLeft = -MiterVec * (Width * MiterScale);
        OutRight = MiterVec * (Width * MiterScale);
    }
    
    return true;
}

/**
 * 为Billboard线段计算斜接向量（屏幕空间等宽版本）
 */
bool ComputeMiterVectorsBillboard(
    float3 Prev,
    float3 Current,
    float3 Next,
    float Width,
    float3 CameraPos,
    out float3 OutLeft,
    out float3 OutRight
)
{
    // 1. 计算线段方向
    float3 DirPrev = normalize(Current - Prev);
    float3 DirNext = normalize(Next - Current);
    
    // 2. 计算到相机的方向
    float3 ToCamera = normalize(CameraPos - Current);
    
    // 3. 计算两条线段的Billboard右向量
    float3 RightPrev = normalize(cross(ToCamera, DirPrev));
    float3 RightNext = normalize(cross(ToCamera, DirNext));
    
    // 4. 计算斜接向量
    float3 MiterVec = normalize(RightPrev + RightNext);
    float MiterLen = length(RightPrev + RightNext);
    
    // 5. 退化情况处理
    if (MiterLen < EPSILON)
    {
        OutLeft = -RightPrev * (Width * 0.5f);
        OutRight = RightPrev * (Width * 0.5f);
        return true;
    }
    
    // 6. 计算斜接比例
    float dotProduct = dot(RightPrev, RightNext);
    float MiterScale = 1.0f / max(dot(MiterVec, RightPrev), EPSILON);
    
    // 7. 限制斜接长度
    MiterScale = min(MiterScale, MITER_LIMIT);
    
    // 8. 输出偏移向量
    float3 Cross = cross(DirPrev, DirNext);
    float TurnSign = dot(Cross, UpVector);
    
    if (TurnSign > 0) // 左转
    {
        OutLeft = MiterVec * (Width * MiterScale);
        OutRight = -MiterVec * (Width * MiterScale);
    }
    else // 右转
    {
        OutLeft = -MiterVec * (Width * MiterScale);
        OutRight = MiterVec * (Width * MiterScale);
    }
    
    return true;
}

/**
 * 写入斜接连接的顶点
 * @param OutBuffer         输出缓冲区
 * @param BaseOffset        基础偏移
 * @param v                 [inout] 顶点计数器
 * @param Vertices          顶点位置数组
 * @param VertexCount       顶点总数
 * @param IsClosed          是否闭合折线
 * @param Width             线宽
 * @param CameraPos         相机位置
 */
void GeneratePolylineWithMiter(
    RWBuffer<float> OutBuffer,
    uint BaseOffset,
    inout int v,
    float3 Vertices[12],  // 立方体的12条边，每条边2个顶点
    uint EdgeCount,
    bool IsClosed,
    float Width,
    float3 CameraPos
)
{
    // 为每条边生成带斜接的线段
    for (uint i = 0; i < EdgeCount; i++)
    {
        uint idx0 = i * 2;        // 边的起点
        uint idx1 = i * 2 + 1;    // 边的终点
        
        float3 P0 = Vertices[idx0];
        float3 P1 = Vertices[idx1];
        
        // 获取前驱和后继顶点
        float3 Prev, Next;
        
        // 起点的前驱
        if (i == 0)
        {
            if (IsClosed)
                Prev = Vertices[(EdgeCount - 1) * 2];
            else
                Prev = P0 - (P1 - P0); // 延伸方向
        }
        else
        {
            Prev = Vertices[(i - 1) * 2];
        }
        
        // 终点的后继
        if (i == EdgeCount - 1)
        {
            if (IsClosed)
                Next = Vertices[1];
            else
                Next = P1 + (P1 - P0); // 延伸方向
        }
        else
        {
            Next = Vertices[(i + 1) * 2 + 1];
        }
        
        // 计算起点的斜接向量
        float3 Left0, Right0;
        ComputeMiterVectorsBillboard(Prev, P0, P1, Width, CameraPos, Left0, Right0);
        
        // 计算终点的斜接向量
        float3 Left1, Right1;
        ComputeMiterVectorsBillboard(P0, P1, Next, Width, CameraPos, Left1, Right1);
        
        // 生成四边形的四个顶点
        float3 V0 = P0 + Left0;
        float3 V1 = P0 + Right0;
        float3 V2 = P1 + Right1;
        float3 V3 = P1 + Left1;
        
        // 写入两个三角形
        WriteVertex(OutBuffer, BaseOffset, v++, V0);
        WriteVertex(OutBuffer, BaseOffset, v++, V1);
        WriteVertex(OutBuffer, BaseOffset, v++, V2);

        
        WriteVertex(OutBuffer, BaseOffset, v++, V0);
        WriteVertex(OutBuffer, BaseOffset, v++, V2);
        WriteVertex(OutBuffer, BaseOffset, v++, V3);

    }
}

