/*=============================================================================
    PopulateBoxChartInstanceBuffer.usf
    集成 Frustum Culling 的版本
=============================================================================*/

#include "/Engine/Private/Common.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
float XSpace;       // [cite: 2]
float YSpace;
int NumColumns;
int NumInstances;
float Time;
float4x4 ViewProjectionMatrix; // <--- 新增：视锥投影矩阵

RWBuffer<float4> OutInstanceOriginBuffer;
RWBuffer<float4> OutInstanceTransforms;
RWBuffer<uint> OutIndirectArgs; // Arg[1] 将作为原子计数器

#define WIDTH 50.0f

bool IsSphereVisible(float3 SphereCenter, float SphereRadius)
{
    // 如果 C++ 传进来的是 ViewProjectionMatrix.GetTransposed()，
    // 那么这里 M[0] 就是 Row 0 (X plane coeffs)。
    // 如果 C++ 没有转置，请在这里使用 transpose(ViewProjectionMatrix)。
    // 强烈建议在 C++ 端转置以保持 Shader 简洁。
    float4x4 M = ViewProjectionMatrix; 

    // 1. 提取视锥平面 (World Space)
    // -------------------------------------------------------------------------
    // Left   : x + w > 0
    // Right  : w - x > 0
    // Bottom : y + w > 0
    // Top    : w - y > 0
    // Near   : z < w (Reversed-Z: w - z > 0)
    // Far    : z > 0 (Reversed-Z)
    // -------------------------------------------------------------------------
    float4 Planes[6];
    Planes[0] = M[3] + M[0]; // Left
    Planes[1] = M[3] - M[0]; // Right
    Planes[2] = M[3] + M[1]; // Bottom
    Planes[3] = M[3] - M[1]; // Top
    Planes[4] = M[3] - M[2]; // Near (Reversed-Z: clip z < clip w)
    Planes[5] = M[2];        // Far  (Reversed-Z: clip z > 0)

    // 2. 剔除测试
    // -------------------------------------------------------------------------
    // 增加一点安全容差，防止 TAA 抖动导致边缘物体闪烁
    float CullRadius = SphereRadius * 1.05;

    [unroll]
    for (int i = 0; i < 6; ++i)
    {
        float4 Plane = Planes[i];
        
        // 关键：平面方程未归一化，所以距离计算也需要归一化因子
        // Dist = (Dot(N, P) + D) / Length(N)
        // Check: Dist < -Radius
        // Optimization: Dot(N, P) + D < -Radius * Length(N)
        
        float PlaneNormalLength = length(Plane.xyz);
        float Dist = dot(Plane.xyz, SphereCenter) + Plane.w;

        if (Dist < -CullRadius * PlaneNormalLength)
        {
            return false; // 只要在一个平面外侧，就彻底不可见
        }
    }

    return true;
}

[numthreads(THREAD_COUNT, 1, 1)]
void MainCS(uint TaskIndex : SV_DispatchThreadID)
{
    // 越界检查
    if (TaskIndex >= (uint)NumInstances) return;

    // 1. 计算位置 (和原逻辑一致) [cite: 6]
    uint Row = TaskIndex / NumColumns;
    uint Col = TaskIndex % NumColumns;
    float3 Position = float3(Col * XSpace, Row * YSpace, 0.0f);

    // 2. 计算高度 (和原逻辑一致) [cite: 7]
    float2 GridCenter = float2(NumColumns * 0.5f, NumInstances / NumColumns * 0.5f);
    float Dist = distance(float2(Col, Row), GridCenter);
    float Wave = sin(Dist * 0.1f - Time * 2.0f) * 0.5f + 0.5f;
    float BarHeight = Wave * 500.0f + 20.0f; // [cite: 9]

    // -----------------------------------------------------------------
    // 3. 构建球形包围盒 (Bounding Sphere)
    // -----------------------------------------------------------------
    
    // 几何体范围是 [Position, Position + (WIDTH, WIDTH, BarHeight)]
    // 中心点 = Position + 半个尺寸
    float3 HalfSize = float3(WIDTH * 0.5f, WIDTH * 0.5f, BarHeight * 0.5f);
    float3 SphereCenter = Position + HalfSize; // [cite: 23, 24]

    float MaxBarHeight = 520.0f; 
    float3 ConservativeHalfSize = float3(WIDTH * 0.5f, WIDTH * 0.5f, MaxBarHeight * 0.5f);
    float ConservativeRadius = length(ConservativeHalfSize);

    // -----------------------------------------------------------------
    // 4. 执行球体剔除
    // -----------------------------------------------------------------
    if (IsSphereVisible(SphereCenter, ConservativeRadius))
    {
        // 5. 如果可见：原子增加计数器，获取写入位置
        uint WriteIndex;
        // OutIndirectArgs[1] 对应 InstanceCount [cite: 17]
        InterlockedAdd(OutIndirectArgs[1], 1, WriteIndex);

        // 6. 写入 Instance Data (逻辑和原来一样，只是索引变了)
        OutInstanceOriginBuffer[WriteIndex] = float4(Position, 1.0f); // 注意用 WriteIndex

        float ScaleX = WIDTH;
        float ScaleY = WIDTH;
        float ScaleZ = BarHeight;

        float4 TransformRow0 = float4(ScaleX, 0.0f, 0.0f, 0.0f); // [cite: 11]
        float4 TransformRow1 = float4(0.0f, ScaleY, 0.0f, 0.0f);
        float4 TransformRow2 = float4(0.0f, 0.0f, ScaleZ, 0.0f);

        uint WriteOffset = WriteIndex * 3; // [cite: 12]
        OutInstanceTransforms[WriteOffset + 0] = TransformRow0;
        OutInstanceTransforms[WriteOffset + 1] = TransformRow1;
        OutInstanceTransforms[WriteOffset + 2] = TransformRow2;
    }

    // 7. 只需要第0号线程去设置其他固定参数
    if (TaskIndex == 0)
    {
        OutIndirectArgs[0] = 36; // IndexCountPerInstance [cite: 15]
        OutIndirectArgs[2] = 0;  // StartIndexLocation [cite: 17]
        OutIndirectArgs[3] = 0;  // BaseVertexLocation
    }
}