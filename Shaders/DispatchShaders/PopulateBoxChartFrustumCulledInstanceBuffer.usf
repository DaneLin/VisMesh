/*=============================================================================
    PopulateBoxChartInstanceBuffer.usf
    集成 Frustum Culling 的版本
=============================================================================*/

#include "/Engine/Private/Common.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
float XSpace;       // [cite: 2]
float YSpace;
int NumColumns;
int NumInstances;
float Time;
float4x4 ViewProjectionMatrix; // <--- 新增：视锥投影矩阵
float4x4 ModelMatrix; // <--- 新增：视锥投影矩阵

RWBuffer<float4> OutInstanceOriginBuffer;
RWBuffer<float4> OutInstanceTransforms;
RWBuffer<uint> OutIndirectArgs; // Arg[1] 将作为原子计数器

#define WIDTH 50.0f

bool IsSphereVisible(float3 SphereCenter, float SphereRadius)
{
    // 如果 C++ 传进来的是 ViewProjectionMatrix.GetTransposed()，
    // 那么这里 M[0] 就是 Row 0 (X plane coeffs)。
    // 如果 C++ 没有转置，请在这里使用 transpose(ViewProjectionMatrix)。
    // 强烈建议在 C++ 端转置以保持 Shader 简洁。
    float4x4 M = ViewProjectionMatrix; 

    // 1. 提取视锥平面 (World Space)
    // -------------------------------------------------------------------------
    // Left   : x + w > 0
    // Right  : w - x > 0
    // Bottom : y + w > 0
    // Top    : w - y > 0
    // Near   : z < w (Reversed-Z: w - z > 0)
    // Far    : z > 0 (Reversed-Z)
    // -------------------------------------------------------------------------
    float4 Planes[6];
    Planes[0] = M[3] + M[0]; // Left
    Planes[1] = M[3] - M[0]; // Right
    Planes[2] = M[3] + M[1]; // Bottom
    Planes[3] = M[3] - M[1]; // Top
    Planes[4] = M[3] - M[2]; // Near (Reversed-Z: clip z < clip w)
    Planes[5] = M[2];        // Far  (Reversed-Z: clip z > 0)

    // 2. 剔除测试
    // -------------------------------------------------------------------------
    // 增加一点安全容差，防止 TAA 抖动导致边缘物体闪烁
    float CullRadius = SphereRadius * 1.05;

    [unroll]
    for (int i = 0; i < 6; ++i)
    {
        float4 Plane = Planes[i];
        
        // 关键：平面方程未归一化，所以距离计算也需要归一化因子
        // Dist = (Dot(N, P) + D) / Length(N)
        // Check: Dist < -Radius
        // Optimization: Dot(N, P) + D < -Radius * Length(N)
        
        float PlaneNormalLength = length(Plane.xyz);
        float Dist = dot(Plane.xyz, SphereCenter) + Plane.w;

        if (Dist < -CullRadius * PlaneNormalLength)
        {
            return false; // 只要在一个平面外侧，就彻底不可见
        }
    }

    return true;
}

[numthreads(THREAD_COUNT, 1, 1)]
void MainCS(uint TaskIndex : SV_DispatchThreadID)
{

    if (TaskIndex >= (uint)NumInstances) return;
    
    uint Row = TaskIndex / NumColumns;
    uint Col = TaskIndex % NumColumns;
    float3 Position = float3(Col * XSpace, Row * YSpace, 0.0f);

    float2 GridCenter = float2(NumColumns * 0.5f, NumInstances / NumColumns * 0.5f);
    float Dist = distance(float2(Col, Row), GridCenter);
    float Wave = sin(Dist * 0.1f - Time * 2.0f) * 0.5f + 0.5f;
    float BarHeight = Wave * 500.0f + 20.0f; 
    
    float3 HalfSize = float3(WIDTH * 0.5f, WIDTH * 0.5f, BarHeight * 0.5f);
    float3 SphereCenter = Position + HalfSize;

    float ConservativeRadius = BarHeight * 0.6f;
    
    SphereCenter = mul(float4(SphereCenter, 1.0f), ModelMatrix).xyz;

    float scale_x = length(float3(ModelMatrix[0][0], ModelMatrix[0][1], ModelMatrix[0][2]));
    float scale_y = length(float3(ModelMatrix[1][0], ModelMatrix[1][1], ModelMatrix[1][2]));
    float scale_z = length(float3(ModelMatrix[2][0], ModelMatrix[2][1], ModelMatrix[2][2]));
    float max_scale = max(max(scale_x, scale_y), scale_z);

    float transformed_radius = ConservativeRadius * max_scale;
    if (IsSphereVisible(SphereCenter, transformed_radius))
    {
        uint WriteIndex;
        InterlockedAdd(OutIndirectArgs[1], 1, WriteIndex);

        OutInstanceOriginBuffer[WriteIndex] = float4(Position, 1.0f); // 注意用 WriteIndex

        float ScaleX = WIDTH;
        float ScaleY = WIDTH;
        float ScaleZ = BarHeight;

        float4 TransformRow0 = float4(ScaleX, 0.0f, 0.0f, 0.0f); 
        float4 TransformRow1 = float4(0.0f, ScaleY, 0.0f, 0.0f);
        float4 TransformRow2 = float4(0.0f, 0.0f, ScaleZ, 0.0f);

        uint WriteOffset = WriteIndex * 3; 
        OutInstanceTransforms[WriteOffset + 0] = TransformRow0;
        OutInstanceTransforms[WriteOffset + 1] = TransformRow1;
        OutInstanceTransforms[WriteOffset + 2] = TransformRow2;
    }

    AllMemoryBarrierWithGroupSync();

    if (TaskIndex == 0)
    {
        OutIndirectArgs[0] = 36; // IndexCountPerInstance
        OutIndirectArgs[2] = 0;  // StartIndexLocation
        OutIndirectArgs[3] = 0;  // BaseVertexLocation
    }
}